# 普及组真题训练
## I 模拟算法
### 1. 不高兴的津津（2004）
**题目描述**

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

**数据输入**

包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

**数据输出**

一行，这一行只包含一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

**输入样例**

~~~c++
5 3
6 2
7 2
5 3
5 4
0 4
0 6
~~~

**输出样例**

~~~c++
3
~~~

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

~~~c#
#include <iostream>
using namespace std;
int main() {
    int mx = 0, ans = 0;
    for (int i = 1; i <= 7; i++) {
        int x, y;
        cin >> x >> y;
        if (x + y > 8 && mx < x + y) 
            mx = x + y, ans = i;
    }
    cout << ans;
    return 0;
}
~~~



### 2. 花生采摘(2004)

**题目描述**

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图1）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![img](http://ybt.ssoier.cn:8088/pic/1927.jpg)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2. 从一棵植株跳到前后左右与之相邻的另一棵植株；
3. 采摘一棵植株下的花生；
4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于$(2,5),(3,7),(4,2),(5,4)(2,5),(3,7),(4,2),(5,4)$的植株下长有花生，个数分别为$13,7,15,913,7,15,9$。沿着图示的路线，多多在$21$个单位时间内，最多可以采到$37$个花生。

**输入数据**

第一行包括三个整数，$M$, $N$和$K$，用空格隔开；表示花生田的大小为$M×N(1≤M,N≤20)$，多多采花生的限定时间为$K(0≤K≤1000)$个单位时间。接下来的$M$行，每行包括$N$个非负整数，也用空格隔开；第$i+1$行的第$j$个整数$P_{ij}(0≤P_{ij}≤500)$表示花生田里植株$(i,j)$下花生的数目，$0$表示该植株下没有花生。

**输出数据**

一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。

**输入样例**

```c++
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```
**输出样例**

```c++
37
```
**样例输入2**
```c++
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```
**样例输出2**

```c++
28
```

**解题思路**

- 时间复杂度：$O(n*m)$
- 空间复杂度：$O(n*m)$

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, k, cnt;
const int N = 20 * 20 + 5;
struct node {
    int x, y, w;
} a[N];

bool cmp(node a, node b) { return a.w > b.w; }

int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            int t;
            cin >> t;
            if (t > 0) {
                cnt++;
                a[cnt].x = i, a[cnt].y = j, a[cnt].w = t;
            }
        }
    sort(a + 1, a + cnt + 1, cmp);
	//初始位置信息
    int xx = 0, yy = a[1].y, ans = 0;
    for (int i = 1; i <= cnt; i++) {
        int dis = abs(xx - a[i].x) + abs(yy - a[i].y);
        if (k >= dis + a[i].x + 1) {  //判断是否能完成采摘
            ans += a[i].w;
            k -= dis + 1;
            //更新位置信息
            xx = a[i].x;
            yy = a[i].y;
            continue;
        }
        break;  //如果无法摘到剩余的最大值，则直接退出 （第一次写的时候忽略了这个点）
    }
    cout << ans;
    return 0;
}
~~~



### 3. 陶陶摘苹果（2005）

**题目描述**

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。

现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。

**输入数据**

两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。

**输出数据**

一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。

**输入样例**

```c++
100 200 150 140 129 134 167 198 200 111 
110
```
**输出样例**
```C++
5
```

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int a[11], h;
int main() {
    for (int i = 1; i <= 10; i++) cin >> a[i];
    cin >> h;
    int ans = 0;
    for (int i = 1; i <= 10; i++)
        if (a[i] <= h + 30) ans++;
    cout << ans;
    return 0;
}
~~~



### 4. 校门外的树（2005）

**题目描述**

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。

由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

**输入数据**

第一行有两个整数L（1 ≤ L ≤ 10000）和 M（1 ≤ M ≤ 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。

**输出数据**

一行，这一行只包含一个整数，表示马路上剩余的树的数目。

**输入样例**
```c++
500 3 
150 300 
100 200 
470 471
```

**输出样例**
```c++
298
```

**提示**
- 对于20%的数据，区域之间没有重合的部分；
- 对于其它的数据，区域之间有重合的情况；

**解题思路**

- 时间复杂度：$O(n)$

- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int L, m;
bool t[10005];
int main() {
    cin >> L >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        for (int j = x; j <= y; j++) t[j] = true;
    }
    int ans = 0;
    for (int i = 0; i <= L; i++)
        if (!t[i]) ans++;
    cout << ans;
    return 0;
}
~~~



### 5. 接水问题（2010）

**题目描述**

学校里有一个水房，水房里一共装有$m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为$1$。

现在有$n$名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从$1$到$n$编号，$i$号同学的接水量为$w_i$。接水开始时，$1$到$m$号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学$j$完成其接水量要求$w_j$ 后，下一名排队等候接水的同学$k$马上接替$j$同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即$j$同学第$x$秒结束时完成接水，则$k$同学第$x+1$秒立刻开始接水。若当前接水人数$n^′$不足$m$，则只有$n^′$个龙头供水，其它$m−n^′$个龙头关闭。

现在给出$n$名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

**输入数据**

第1 行2 个整数$n$和$m$，用一个空格隔开，分别表示接水人数和龙头个数。

第2 行n 个整数$w_1、w_2、……、w_n$，每两个整数之间用一个空格隔开，$wi$表示$i$号同学的接水量。

**输出数据**

只有一行，$1$个整数，表示接水所需的总时间。

**输入样例**

```c++
5 3 
4 4 1 2 1
```

**输出样例**
```c++
4 
```
**输入输出样例说明**

第1 秒，3 人接水。第1 秒结束时，1、2、3 号同学每人的已接水量为1，3 号同学接完水，4 号同学接替3 号同学开始接水。第2 秒，3 人接水。第2 秒结束时，1、2 号同学每人的已接水量为2，4 号同学的已接水量为1。第3 秒，3 人接水。第3 秒结束时，1、2 号同学每人的已接水量为3，4 号同学的已接水量为2。4 号同学接完水，5 号同学接替4 号同学开始接水。第4 秒，3 人接水。第4 秒结束时，1、2 号同学每人的已接水量为4，5 号同学的已接水量为1。1、2、5 号同学接完水，即所有人完成接水。总接水时间为4 秒。

**输入样例2**

```c++
8 4 
23 71 87 32 70 93 80 76
```
**输出样例2**
```c++
163
```
**数据范围**

$1≤n≤10000$，$1≤m≤100$且$m≤n$；

$1≤w_i≤100$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
const int N = 100;
int n, m;
int q[N];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> q[i];
    for (int i = m + 1; i <= n; i++) {
        int x;
        cin >> x;
        int mi = 1e9, idx = 0;
        for (int j = 1; j <= m; j++)
            if (q[j] < mi) mi = q[j], idx = j;
        q[idx] += x;
    }
    int ans = 0;
    for (int i = 1; i <= m; i++)
        if (ans < q[i]) ans = q[i];
    cout << ans;
    return 0;
}
~~~



### 6. 寻宝（2014）

**题目描述**

传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：

藏宝楼共有 N+1 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 N 层，每层 M 个房间，这 M 个房间围成一圈并按逆时针方向依次编号为 0，…，M-1。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 x，表示从这个房间开始按逆时针方向选择第 x 个有楼梯的房间（假定该房间的编号为 k），从该房间上楼，上楼后到达上一层的 k 号房间。比如当前房间的指示牌上写着 2，则按逆时针方向开始尝试，找到第 2 个有楼梯的房间，从该房间上楼。

如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。

请帮助小明算出这个打开宝箱的密钥。

**输入数据**

第一行 2 个整数 N 和 M，之间用一个空格隔开。N 表示除了顶层外藏宝楼共 N 层楼，M 表示除顶层外每层楼有 M 个房间。

接下来 $N*M$ 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第$(i-1)*M+j$行表示第 i 层 j-1 号房间的情况（i=1, 2, …, N；j=1, 2, … ,M）。第一个整数表示该房间是否有楼梯通往上一层（0 表示没有，1 表示有），第二个整数表示指示牌上的数字。注意，从 j 号房间的楼梯爬到上一层到达的房间一定也是 j 号房间。

最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从 0 开始）。

**输出数据**

输出只有一行，一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对 20123取模的结果即可。

**输入样例**

~~~c++
2 3 
1 2 
0 3 
1 4 
0 1 
1 5 
1 2 
1
~~~

**输出样例**

~~~c++
5
~~~

**输入输出样例说明**

第一层：

- 0 号房间，有楼梯通往上层，指示牌上的数字是 2；
- 1 号房间，无楼梯通往上层，指示牌上的数字是 3；
- 2 号房间，有楼梯通往上层，指示牌上的数字是 4；

第二层：

- 0 号房间，无楼梯通往上层，指示牌上的数字是 1；
- 1 号房间，有楼梯通往上层，指示牌上的数字是 5；
- 2 号房间，有楼梯通往上层，指示牌上的数字是 2；

小明首先进入第一层（底层）的 1 号房间，记下指示牌上的数字为 3，然后从这个房间开始，沿逆时针方向选择第 3 个有楼梯的房间 2 号房间进入，上楼后到达第二层的 2 号房间，记下指示牌上的数字为 2，由于当前房间本身有楼梯通向上层，该房间作为第一个有楼梯的房间。因此，此时沿逆时针方向选择第 2 个有楼梯的房间即为 1 号房间，进入后上楼梯到达顶层。这时把上述记下的指示牌上的数字加起来，即 3+2=5，所以打开宝箱的密钥就是 5。

**数据范围**

对于 50%数据，有 $0<N≤1000，0<x≤10000$；

对于 100%数据，有 $0<N≤10000，0<M≤100，0<x≤1,000,000$。

**解题思路**

时间复杂度：$O(n*m)$

空间复杂度：$ O(n*m)$

~~~c++
#include <iostream>
using namespace std;
const int N = 10005, M = 105;
int n, m, k;
int f[N][M], x[N][M], c[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < m; j++) {
            scanf("%d%d", &f[i][j], &x[i][j]);
            if (f[i][j] == 1) c[i]++;
        }
    scanf("%d", &k);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        ans = (ans + x[i][k]) % 20123;
        int p = x[i][k] % c[i];
        if (p == 0) p = c[i];
        while (1) {
            if (f[i][k] == 1) p--;
            if (p == 0) break;
            k = (k + 1) % m;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 7. 买铅笔(2016)

**题目描述**

P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有3种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起见，P老师决定只买同一种包装的铅笔。

商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过n支铅笔才够给小朋友们发礼物。

现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少n支铅笔最少需要花费多少钱。

**输入数据**

输入的第一行包含一个正整数n，表示需要的铅笔数量。

接下来三行，每行用两个正整数描述一种包装的铅笔:其中第一个整数表示这种包装内铅笔的数量，第二个整数表示这种包装的价格。

保证所有的7个数都是不超过10000的正整数。

**输出数据**

输出一行一个整数，表示P老师最少需要花费的钱。

**输入样例**

```c++
57 
2 2 
50 30 
30 27
```
**输出样例**

```c++
54
```

**提示**
铅笔的三种包装分别是:
- 2支装，价格为2;
- 50支装，价格为30;
- 30支装，价格为27。
P老师需要购买至少57支铅笔。如果她选择购买第一种包装，那么她需要购买29份，共计2x29=58支，需要花费的钱为$2*29=58$实际上，P老师会选择购买第三种包装，这样需要买2份。虽然最后买到的铅笔数量更多了，为$30*2=60$支，但花费却减少为$27*2=54$，比第一种少。对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买2份，实际的花费达到了$30*2=60$，因此P老师也不会选择。所以最后输出的答案是54

**样例输入2**

```c++
9998 
128 233 
128 2333 
128 666
```

**样例输出2**
```c++
18407
```

**样例输入3**

```c++
9999 
101 1111 
1 9999 
1111 9999
```

**样例输出3**
```c++
89991
```

**数据规模**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

| 测试点      | 整倍数 | 其他特点                       |
| ----------- | ------ | ------------------------------ |
| 1,2,3,4     | √      | 三种包装内的铅笔数量都是相同的 |
| 5,6,7,8     | ×      | 三种包装内的铅笔数量都是相同的 |
| 9,10,11,12  | √      | 后两种包装的铅笔数量都是相同的 |
| 13,14,15,16 | ×      | 后两种包装的铅笔数量都是相同的 |
| 17,18       | √      | 没有特殊性质                   |

上表中“整倍数”的意义为:若为“k”，表示对应数据所需要的铅笔数量n一定是每种包装铅笔数量的整倍数(这意味着一定可以不用多买铅笔)。

**解题思路**

~~~c++
#include <cmath>
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int ans = 1e9;
    for (int i = 1; i <= 3; i++) {
        int x, y;
        cin >> x >> y;
        int cnt = ceil(n * 1.0 / x);
        ans = min(ans, cnt * y);
    }
    cout << ans;
    return 0;
}
~~~



### 8. 标题统计（2018）

**题目描述**

凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？

注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字符数时，空格和换行符不计算在内。

**输入数据**

输入只有一行，一个字符串 s。

**输出数据**

输出只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。

**输入样例**

```c++
234
```
**输出样例**
```c++
3
```
**样例1说明**

标题中共有 3 个字符，这 3 个字符都是数字字符。

**样例输入2**

```c++
Ca 45
```

**样例输出2**

```c++
4
```
**样例2说明**

标题中共有 5 个字符，包括 1 个大写英文字母，1 个小写英文字母和 2 个数字字符，还有 1 个空格。由于空格不计入结果中，故标题的有效字符数为 4 个。

**数据规模与约定**

规定$ |s|$表示字符串 s 的长度（即字符串中的字符和空格数）。

对于 40%的数据，$1≤|s|≤5$，保证输入为数字字符及行末换行符。

对于 80% 的数据，$1≤|s|≤5$，输入只可能包含大、小写英文字母、数字字符及行末换行符。

对于 100% 的数据，$1≤|s|≤5$，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。

**解题思路**

~~~c++
#include <cstring>
#include <iostream>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    int ans = 0;
    for (int i = 0; s[i]; i++)
        if (s[i] != ' ') ans++;
    cout << ans;
    return 0;
}
~~~



## II 枚举算法

### 1. 数字统计（2010）

**题目描述**

请统计某个给定范围[L, R]的所有整数中，数字2 出现的次数。

比如给定范围[2, 22]，数字2 在数2 中出现了1 次，在数12 中出现1 次，在数20 中出现1 次，在数21 中出现1 次，在数22 中出现2 次，所以数字2 在该范围内一共出现了6次。

**输入数据**

共1 行，为两个正整数L 和R，之间用一个空格隔开。

**输出数据**

共1 行，表示数字2 出现的次数。

**输入样例**

```c++
2 22
```
**输出样例**

```c++
6
```

**输入样例2**

```c++
2 100
```

**输出样例2**

```c++
20
```
**数据范围**
$1 ≤ L ≤ R≤ 10000$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;

int main() {
    int l, r;
    cin >> l >> r;
    int ans = 0;
    for (int i = l; i <= r; i++) {
        int t = i;
        while (t) {
            if (t % 10 == 2) ans++;
            t /= 10;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 2. 导弹拦截（2010）

**题目描述**

经过11 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为0 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

**输入数据**

第一行包含4 个整数$x_1、y_1、x_2、y_2$，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为$(x_1, y_1)、(x_2, y_2)$。

第二行包含1 个整数N，表示有N 颗导弹。接下来N 行，每行两个整数x、y，中间用一个空格隔开，表示一颗导弹的坐标(x, y)。不同导弹的坐标可能相同。

**提示**

两个点$(x_1, y_1)、(x_2, y_2)$之间距离的平方是$(x_1− x_2)^2+(y_1−y_2)^2$。

两套系统工作半径$r_1、r_2$ 的平方和，是指$r_1、r_2$ 分别取平方后再求和，即$r_1^2+r_2^2$。

**输出数据**

只有一行，包含一个整数，即当天的最小使用代价。

**输入样例**

~~~c++
0 0 10 0 
2
-3 3
10 0
~~~

**输出样例**

~~~c++
18
~~~

**样例 1 说明**
样例1 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为18 和0。

**输入样例2**

~~~c++
0 0 6 0 
5 
-4 -2 
-2 3 
4 0 
6 -2 
9 1
~~~

**输出样例2**

~~~c++
30
~~~

**样例2 说明**

样例中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为20 和10。

![img](http://ybt.ssoier.cn:8088/pic/1951.gif)
**数据范围**

对于10%的数据，N = 1

对于20%的数据，1 ≤ N ≤ 2

对于40%的数据，1 ≤ N ≤ 100

对于70%的数据，1 ≤ N ≤ 1000

对于100%的数据，1 ≤ N ≤ 100000，且所有坐标分量的绝对值都不超过1000。

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
const int N = 100005;

struct node {
    int x, y, d1, d2;
} a[N];

bool cmp(node a, node b) { return a.d1 > b.d1; }

int main() {
    int x1, y1, x2, y2, n;
    cin >> x1 >> y1 >> x2 >> y2;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y;
        a[i].d1 = (a[i].x - x1) * (a[i].x - x1) + (a[i].y - y1) * (a[i].y - y1);
        a[i].d2 = (a[i].x - x2) * (a[i].x - x2) + (a[i].y - y2) * (a[i].y - y2);
    }
    sort(a + 1, a + n + 1, cmp);
    int ans = a[1].d1, k = 0;
    for (int i = 2; i <= n; i++) {
        k = max(k, a[i - 1].d2);
        ans = min(ans, a[i].d1 + k);
    }
    k = max(k, a[n].d2);
    ans = min(ans, k);
    cout << ans;
    return 0;
}
~~~



### 3. 质因数分解(2012)

**题目描述**

已知正整数 n 是两个不同的质数的乘积，试求出较大的那个质数。

**输入数据**

输入只有一行，包含一个正整数 n。

**输出数据**

输出只有一行，包含一个正整数 p，即较大的那个质数。

**输入样例**

```c++
21
```

**输出样例**

```c++
7
```

**数据范围**

对于 60%的数据，$6 ≤ n ≤ 1000$。

对于 100%的数据，$6 ≤ n ≤ 2*10^9$。

**解题思路**

- 时间复杂度：$O(\sqrt{n})$

~~~c++
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++)
        if (n % i == 0) {
            cout << n / i;
            return 0;
        }
    return 0;
}
~~~



### 4. 计数问题(2013)

**题目描述**

试计算在区间 1 到 n 的所有整数中，数字 $x（0≤x≤9）$共出现了多少次？例如，在 1 到 11 中，即在 1、2、3、4、5、6、7、8、9、10、11 中，数字 1 出现了 4 次。

**输入数据**

输入共 1 行，包含 22 个整数 $n、x$ 之间用一个空格隔开。

**输出数据**

输出共 1 行，包含一个整数，表示 x 出现的次数。

**输入样例**

```c++
11 1
```
**输出样例**

```c++
4
```

**数据说明**

对于 100%的数据，$1≤n≤1,000,000，0≤x≤9$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;

int main() {
    int n, x;
    cin >> n >> x;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int t = i;
        while (t) {
            if (t % 10 == x) ans++;
            t /= 10;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 5. 珠心算测验（2014）

**题目描述**

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。

某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？

最近老师出了一些测验题，请你帮忙求出答案。

**输入数据**

输入共两行，第一行包含一个整数 n，表示测试题中给出的正整数个数。

第二行有 n 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。

**输出数据**

输出共一行，包含一个整数，表示测验题答案。

**输入样例**

```c++
4 
1 2 3 4
```

**输出样例**

```c++
2
```

**样例说明**

由 1+2=3，1+3=4，故满足测试要求的答案为 2。注意，加数和被加数必须是集合中的两个不同的数。

**数据说明**

对于 100%的数据，3  ≤  n  ≤  100，测验题给出的正整数大小不超过 10,000。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
int n, a[101], f[20005];
int main() {
    int ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i < n; i++)
        for (int j = i + 1; j <= n; j++) f[a[i] + a[j]] = 1;  //避免重复计算
    for (int i = 1; i <= n; i++) ans += f[a[i]];
    cout << ans;
    return 0;
}
~~~



### 6. 比例简化（2014）

**题目描述**

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 1498 人，反对的有 902 人，那么赞同与反对的比例可以简单的记为$1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 A，反对人数 B，以及一个上限 L，请你将 A 比 B 化简为 A’比 B’，要求在 A’和 B’均不大于 L 且 A’和 B’互质（两个整数的最大公约数是 1）的前提下，A’/B’ ≥ A/B且 A’/B’ - A/B 的值尽可能小。

**输入格式**

输入共一行，包含三个整数 A，B，L，每两个整数之间用一个空格隔开，分别表示支持人数、反对人数以及上限。

**输出格式**

输出共一行，包含两个整数 A’，B’，中间用一个空格隔开，表示化简后的比例。

**输入样例**

~~~c++
1498 902 10
~~~

**输出样例**

~~~c++
5 3
~~~

**数据说明**

对于 100%的数据，1  ≤  A  ≤  1,000,000，1  ≤  B  ≤  1,000,000，1  ≤  L  ≤  100， A/B  ≤  L。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
int A, B, L;

int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

int main() {
    cin >> A >> B >> L;
    int a, b;
    double mi = 1e9;
    for (int i = 1; i <= L; i++)
        for (int j = 1; j <= L; j++)
            if (gcd(i, j) == 1 && i * 1.0 / j >= A * 1.0 / B) {
                double t = i * 1.0 / j - A * 1.0 / B;
                if (mi > t) {
                    a = i;
                    b = j;
                    mi = t;
                }
            }
    cout << a << " " << b;
    return 0;
}
~~~



### 7. 扫雷游戏(2015)

**题目描述**

扫雷游戏是一款十分经典的单机小游戏。在n行m列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出 n 行 m 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。

**输入格式**

第一行是用一个空格隔开的两个整数 n 和 m ，分别表示雷区的行数和列数。

接下来 n 行，每行 m 个字符，描述了雷区中的地雷分布情况。字符’`*`’表示相应格子是地雷格，字符’`?`’表示相应格子是非地雷格。相邻字符之间无分隔符。

**输出格式**

包含 n 行，每行 m 个字符，描述整个雷区。用’`*`’表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。

**输入样例**

```c++
3 3 
*?? 
??? 
?*?
```

**输出样例**

```c++
*10 
221 
1*1
```

**输入样例2**

```c++
2 3 
?*? 
*??
```

**输出样例1**

```c++
2*1 
*21
```

对于 100%的数据， $1≤n≤100，1≤m≤100$。

**解题思路**

~~~c++
#include <bits/stdc++.h>
using namespace std;
const int dr[8][2] = {{1, 0}, {0, 1}, { -1, 0}, {0, -1}, {1, 1}, { -1, 1}, {1, -1}, { -1, -1}};
int n, m;
char mp[105][105];

int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			cin >> mp[i][j];
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(mp[i][j] == '?') {
				int cnt = 0;
				for(int k = 0; k < 8; k++) {
					int nx = i + dr[k][0];
					int ny = j + dr[k][1];
					if(mp[nx][ny] == '*')
						cnt++;
				}
				mp[i][j] = cnt + '0';
			}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++)
			cout << mp[i][j];
		cout << endl;
	}
	return 0;
}
~~~



### 8. 回文日期（2016）

**题目描述**

日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。显然:一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。现在，牛牛想知道:在他指定的两个日期之间(包含这两个日期本身)，有多少个真实存在的日期是回文的。

**提示**

一个 8 位数字是回文的，当且仅当对于所有的$i(1<i<8)$从左向右数的第 i 个数字和第$9−i$个数字(即从右向左数的第 i 个数字)是相同的。

例如:

- 对于2016年11月19日，用8位数字20161119表示，它不是回文的。

- 对于2010年1月2日，用8位数字20100102表示，它是回文的。

- 对于2010年10月2日，用8位数字20101002表示，它不是回文的。

每一年中都有12个月份：

其中：

- 1 , 3 , 5 , 7 , 8 , 10 , 12月每个月有31天
- 4 , 6 , 9 , 11 月每个月有30天
- 而对于 2 月，闰年时有 29 天，平年时有 28 天

一个年份是闰年当且仅当它满足下列两种情况其中的一种:

- 这个年份是4的整数倍，但不是100的整数倍;

- 这个年份是400的整数倍。

例如:

- 以下几个年份都是闰年:2000 ,2012 ,2016

- 以下几个年份是平年:1900,2011,2014

**输入格式**

输入包括两行，每行包括一个8位数字。

第一行表示牛牛指定的起始日期date1

第二行表示牛牛指定的终止日期date2

保证date1和date2都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。

保证date1一定不晚于date2。

**输出格式**

输出一行，包含一个整数，表示在date1和date2之间，有多少个日期是回文的。

**输入样例**

~~~c++
20110101 
20111231
~~~

**输出样例** 

~~~c++
1
~~~

**样例输入2** 

~~~c++
20000101 
20101231
~~~

**样例输出2**

~~~c++
2
~~~

**提示**

对于样例1，符合条件的日期是20111102

对于样例2，符合条件的日期是20011002和20100102

对于60%的数据，满足date1=date2。

**解题思路**

~~~c++

~~~







