# 普及组真题训练
## I 模拟算法
### 1. 不高兴的津津（2004）
**题目描述**

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

**数据输入**

包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

**数据输出**

一行，这一行只包含一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

**输入样例**

~~~c++
5 3
6 2
7 2
5 3
5 4
0 4
0 6
~~~

**输出样例**

~~~c++
3
~~~

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

~~~c#
#include <iostream>
using namespace std;
int main() {
    int mx = 0, ans = 0;
    for (int i = 1; i <= 7; i++) {
        int x, y;
        cin >> x >> y;
        if (x + y > 8 && mx < x + y) 
            mx = x + y, ans = i;
    }
    cout << ans;
    return 0;
}
~~~



### 2. 花生采摘(2004)

**题目描述**

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图1）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![img](http://ybt.ssoier.cn:8088/pic/1927.jpg)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2. 从一棵植株跳到前后左右与之相邻的另一棵植株；
3. 采摘一棵植株下的花生；
4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于$(2,5),(3,7),(4,2),(5,4)(2,5),(3,7),(4,2),(5,4)$的植株下长有花生，个数分别为$13,7,15,913,7,15,9$。沿着图示的路线，多多在$21$个单位时间内，最多可以采到$37$个花生。

**输入数据**

第一行包括三个整数，$M$, $N$和$K$，用空格隔开；表示花生田的大小为$M×N(1≤M,N≤20)$，多多采花生的限定时间为$K(0≤K≤1000)$个单位时间。接下来的$M$行，每行包括$N$个非负整数，也用空格隔开；第$i+1$行的第$j$个整数$P_{ij}(0≤P_{ij}≤500)$表示花生田里植株$(i,j)$下花生的数目，$0$表示该植株下没有花生。

**输出数据**

一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。

**输入样例**

```c++
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```
**输出样例**

```c++
37
```
**样例输入2**
```c++
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```
**样例输出2**

```c++
28
```

**解题思路**

- 时间复杂度：$O(n*m)$
- 空间复杂度：$O(n*m)$

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, k, cnt;
const int N = 20 * 20 + 5;
struct node {
    int x, y, w;
} a[N];

bool cmp(node a, node b) { return a.w > b.w; }

int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            int t;
            cin >> t;
            if (t > 0) {
                cnt++;
                a[cnt].x = i, a[cnt].y = j, a[cnt].w = t;
            }
        }
    sort(a + 1, a + cnt + 1, cmp);
	//初始位置信息
    int xx = 0, yy = a[1].y, ans = 0;
    for (int i = 1; i <= cnt; i++) {
        int dis = abs(xx - a[i].x) + abs(yy - a[i].y);
        if (k >= dis + a[i].x + 1) {  //判断是否能完成采摘
            ans += a[i].w;
            k -= dis + 1;
            //更新位置信息
            xx = a[i].x;
            yy = a[i].y;
            continue;
        }
        break;  //如果无法摘到剩余的最大值，则直接退出 （第一次写的时候忽略了这个点）
    }
    cout << ans;
    return 0;
}
~~~



### 3. 陶陶摘苹果（2005）

**题目描述**

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。

现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。

**输入数据**

两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。

**输出数据**

一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。

**输入样例**

```c++
100 200 150 140 129 134 167 198 200 111 
110
```
**输出样例**
```C++
5
```

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int a[11], h;
int main() {
    for (int i = 1; i <= 10; i++) cin >> a[i];
    cin >> h;
    int ans = 0;
    for (int i = 1; i <= 10; i++)
        if (a[i] <= h + 30) ans++;
    cout << ans;
    return 0;
}
~~~



### 4. 校门外的树（2005）

**题目描述**

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。

由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

**输入数据**

第一行有两个整数L（1 ≤ L ≤ 10000）和 M（1 ≤ M ≤ 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。

**输出数据**

一行，这一行只包含一个整数，表示马路上剩余的树的数目。

**输入样例**
```c++
500 3 
150 300 
100 200 
470 471
```

**输出样例**
```c++
298
```

**提示**
- 对于20%的数据，区域之间没有重合的部分；
- 对于其它的数据，区域之间有重合的情况；

**解题思路**

- 时间复杂度：$O(n)$

- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int L, m;
bool t[10005];
int main() {
    cin >> L >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        for (int j = x; j <= y; j++) t[j] = true;
    }
    int ans = 0;
    for (int i = 0; i <= L; i++)
        if (!t[i]) ans++;
    cout << ans;
    return 0;
}
~~~



### 5. 接水问题（2010）

**题目描述**

学校里有一个水房，水房里一共装有$m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为$1$。

现在有$n$名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从$1$到$n$编号，$i$号同学的接水量为$w_i$。接水开始时，$1$到$m$号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学$j$完成其接水量要求$w_j$ 后，下一名排队等候接水的同学$k$马上接替$j$同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即$j$同学第$x$秒结束时完成接水，则$k$同学第$x+1$秒立刻开始接水。若当前接水人数$n^′$不足$m$，则只有$n^′$个龙头供水，其它$m−n^′$个龙头关闭。

现在给出$n$名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

**输入数据**

第1 行2 个整数$n$和$m$，用一个空格隔开，分别表示接水人数和龙头个数。

第2 行n 个整数$w_1、w_2、……、w_n$，每两个整数之间用一个空格隔开，$wi$表示$i$号同学的接水量。

**输出数据**

只有一行，$1$个整数，表示接水所需的总时间。

**输入样例**

```c++
5 3 
4 4 1 2 1
```

**输出样例**
```c++
4 
```
**输入输出样例说明**

第1 秒，3 人接水。第1 秒结束时，1、2、3 号同学每人的已接水量为1，3 号同学接完水，4 号同学接替3 号同学开始接水。第2 秒，3 人接水。第2 秒结束时，1、2 号同学每人的已接水量为2，4 号同学的已接水量为1。第3 秒，3 人接水。第3 秒结束时，1、2 号同学每人的已接水量为3，4 号同学的已接水量为2。4 号同学接完水，5 号同学接替4 号同学开始接水。第4 秒，3 人接水。第4 秒结束时，1、2 号同学每人的已接水量为4，5 号同学的已接水量为1。1、2、5 号同学接完水，即所有人完成接水。总接水时间为4 秒。

**输入样例2**

```c++
8 4 
23 71 87 32 70 93 80 76
```
**输出样例2**
```c++
163
```
**数据范围**

$1≤n≤10000$，$1≤m≤100$且$m≤n$；

$1≤w_i≤100$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
const int N = 100;
int n, m;
int q[N];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> q[i];
    for (int i = m + 1; i <= n; i++) {
        int x;
        cin >> x;
        int mi = 1e9, idx = 0;
        for (int j = 1; j <= m; j++)
            if (q[j] < mi) mi = q[j], idx = j;
        q[idx] += x;
    }
    int ans = 0;
    for (int i = 1; i <= m; i++)
        if (ans < q[i]) ans = q[i];
    cout << ans;
    return 0;
}
~~~



### 6. 寻宝（2014）

**题目描述**

传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：

藏宝楼共有 N+1 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 N 层，每层 M 个房间，这 M 个房间围成一圈并按逆时针方向依次编号为 0，…，M-1。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 x，表示从这个房间开始按逆时针方向选择第 x 个有楼梯的房间（假定该房间的编号为 k），从该房间上楼，上楼后到达上一层的 k 号房间。比如当前房间的指示牌上写着 2，则按逆时针方向开始尝试，找到第 2 个有楼梯的房间，从该房间上楼。

如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。

请帮助小明算出这个打开宝箱的密钥。

**输入数据**

第一行 2 个整数 N 和 M，之间用一个空格隔开。N 表示除了顶层外藏宝楼共 N 层楼，M 表示除顶层外每层楼有 M 个房间。

接下来 $N*M$ 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第$(i-1)*M+j$行表示第 i 层 j-1 号房间的情况（i=1, 2, …, N；j=1, 2, … ,M）。第一个整数表示该房间是否有楼梯通往上一层（0 表示没有，1 表示有），第二个整数表示指示牌上的数字。注意，从 j 号房间的楼梯爬到上一层到达的房间一定也是 j 号房间。

最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从 0 开始）。

**输出数据**

输出只有一行，一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对 20123取模的结果即可。

**输入样例**

~~~c++
2 3 
1 2 
0 3 
1 4 
0 1 
1 5 
1 2 
1
~~~

**输出样例**

~~~c++
5
~~~

**输入输出样例说明**

第一层：

- 0 号房间，有楼梯通往上层，指示牌上的数字是 2；
- 1 号房间，无楼梯通往上层，指示牌上的数字是 3；
- 2 号房间，有楼梯通往上层，指示牌上的数字是 4；

第二层：

- 0 号房间，无楼梯通往上层，指示牌上的数字是 1；
- 1 号房间，有楼梯通往上层，指示牌上的数字是 5；
- 2 号房间，有楼梯通往上层，指示牌上的数字是 2；

小明首先进入第一层（底层）的 1 号房间，记下指示牌上的数字为 3，然后从这个房间开始，沿逆时针方向选择第 3 个有楼梯的房间 2 号房间进入，上楼后到达第二层的 2 号房间，记下指示牌上的数字为 2，由于当前房间本身有楼梯通向上层，该房间作为第一个有楼梯的房间。因此，此时沿逆时针方向选择第 2 个有楼梯的房间即为 1 号房间，进入后上楼梯到达顶层。这时把上述记下的指示牌上的数字加起来，即 3+2=5，所以打开宝箱的密钥就是 5。

**数据范围**

对于 50%数据，有 $0<N≤1000，0<x≤10000$；

对于 100%数据，有 $0<N≤10000，0<M≤100，0<x≤1,000,000$。

**解题思路**

时间复杂度：$O(n*m)$

空间复杂度：$ O(n*m)$

~~~c++
#include <iostream>
using namespace std;
const int N = 10005, M = 105;
int n, m, k;
int f[N][M], x[N][M], c[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < m; j++) {
            scanf("%d%d", &f[i][j], &x[i][j]);
            if (f[i][j] == 1) c[i]++;
        }
    scanf("%d", &k);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        ans = (ans + x[i][k]) % 20123;
        int p = x[i][k] % c[i];
        if (p == 0) p = c[i];
        while (1) {
            if (f[i][k] == 1) p--;
            if (p == 0) break;
            k = (k + 1) % m;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 7. 买铅笔(2016)

**题目描述**

P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有3种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起见，P老师决定只买同一种包装的铅笔。

商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过n支铅笔才够给小朋友们发礼物。

现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少n支铅笔最少需要花费多少钱。

**输入数据**

输入的第一行包含一个正整数n，表示需要的铅笔数量。

接下来三行，每行用两个正整数描述一种包装的铅笔:其中第一个整数表示这种包装内铅笔的数量，第二个整数表示这种包装的价格。

保证所有的7个数都是不超过10000的正整数。

**输出数据**

输出一行一个整数，表示P老师最少需要花费的钱。

**输入样例**

```c++
57 
2 2 
50 30 
30 27
```
**输出样例**

```c++
54
```

**提示**
铅笔的三种包装分别是:
- 2支装，价格为2;
- 50支装，价格为30;
- 30支装，价格为27。
P老师需要购买至少57支铅笔。如果她选择购买第一种包装，那么她需要购买29份，共计2x29=58支，需要花费的钱为$2*29=58$实际上，P老师会选择购买第三种包装，这样需要买2份。虽然最后买到的铅笔数量更多了，为$30*2=60$支，但花费却减少为$27*2=54$，比第一种少。对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买2份，实际的花费达到了$30*2=60$，因此P老师也不会选择。所以最后输出的答案是54

**样例输入2**

```c++
9998 
128 233 
128 2333 
128 666
```

**样例输出2**
```c++
18407
```

**样例输入3**

```c++
9999 
101 1111 
1 9999 
1111 9999
```

**样例输出3**
```c++
89991
```

**数据规模**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

| 测试点      | 整倍数 | 其他特点                       |
| ----------- | ------ | ------------------------------ |
| 1,2,3,4     | √      | 三种包装内的铅笔数量都是相同的 |
| 5,6,7,8     | ×      | 三种包装内的铅笔数量都是相同的 |
| 9,10,11,12  | √      | 后两种包装的铅笔数量都是相同的 |
| 13,14,15,16 | ×      | 后两种包装的铅笔数量都是相同的 |
| 17,18       | √      | 没有特殊性质                   |

上表中“整倍数”的意义为:若为“k”，表示对应数据所需要的铅笔数量n一定是每种包装铅笔数量的整倍数(这意味着一定可以不用多买铅笔)。

**解题思路**

~~~c++
#include <cmath>
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int ans = 1e9;
    for (int i = 1; i <= 3; i++) {
        int x, y;
        cin >> x >> y;
        int cnt = ceil(n * 1.0 / x);
        ans = min(ans, cnt * y);
    }
    cout << ans;
    return 0;
}
~~~



### 8. 标题统计（2018）

**题目描述**

凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？

注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字符数时，空格和换行符不计算在内。

**输入数据**

输入只有一行，一个字符串 s。

**输出数据**

输出只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。

**输入样例**

```c++
234
```
**输出样例**
```c++
3
```
**样例1说明**

标题中共有 3 个字符，这 3 个字符都是数字字符。

**样例输入2**

```c++
Ca 45
```

**样例输出2**

```c++
4
```
**样例2说明**

标题中共有 5 个字符，包括 1 个大写英文字母，1 个小写英文字母和 2 个数字字符，还有 1 个空格。由于空格不计入结果中，故标题的有效字符数为 4 个。

**数据规模与约定**

规定$ |s|$表示字符串 s 的长度（即字符串中的字符和空格数）。

对于 40%的数据，$1≤|s|≤5$，保证输入为数字字符及行末换行符。

对于 80% 的数据，$1≤|s|≤5$，输入只可能包含大、小写英文字母、数字字符及行末换行符。

对于 100% 的数据，$1≤|s|≤5$，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。

**解题思路**

~~~c++
#include <cstring>
#include <iostream>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    int ans = 0;
    for (int i = 0; s[i]; i++)
        if (s[i] != ' ') ans++;
    cout << ans;
    return 0;
}
~~~



### 9. 成绩（2017）

**题目描述**

牛牛最近学习了 C++入门课程，这门课程的总成绩计算方法是：

​						总成绩 = 作业成绩 × 20% + 小测成绩 × 30% + 期末考试成绩 × 50%

牛牛想知道，这门课程自己最终能得到多少分。

**输入格式**

只有 1 行，包含三个非负整数A、B、C，分别表示牛牛的作业成绩、小测 成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 100 分。

**输出格式**

只有 1 行，包含一个整数，即牛牛这门课程的总成绩，满分也是 100 分。

**输入样例1**

```c++
100 100 80
```

**输出样例1**

```c++
90
```

**样例说明** 

牛牛的作业成绩是 100 分，小测成绩是 100 分，期末考试成绩是 80 分，总成 绩是 100 × 20% + 100 × 30% + 80 × 50% = 20 + 30 + 40 = 90。

**输入样例2**

```c++
60 90 80
```
**输出样例2**

```c++
79
```

**样例说明**

牛牛的作业成绩是 60 分，小测成绩是 90 分，期末考试成绩是 80 分，总成绩是 60 × 20% + 90 × 30% + 80 × 50% = 12 + 27 + 40 = 79。

**数据说明**

对于 30% 的数据，A = B = 0。
对于另外 30% 的数据，A = B = 100。
对于 100% 的数据， 0 ≤ A、B、C ≤ 100 且 A、B、C 都是 10 的整数倍。

**解题思路**

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

~~~c++
#include <iostream>
using namespace std;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    cout << a * 20 / 100 + b * 30 / 100 + c * 50 / 100 << endl;
    return 0;
}
~~~



### 10. 金币（2015）

**题目描述**

国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续N天每天收到N枚金币后，骑士会在之后的连续N+1天里，每天收到N+1枚金币。

请计算在前K天里，骑士一共获得了多少金币。

**输入格式**

只有1行，包含一个正整数K，表示发放金币的天数。

**输出格式**

只有1行，包含一个正整数，即骑士收到的金币数。

**输入样例1**

```c++
6
```

**输出样例1**

```c++
14
```

**输入样例2**

```c++
1000
```

**输出样例2**

```c++
29820
```

**解题思路**

- 时间复杂度$O(n)$
- 空间复杂度$O(1)$

~~~c++
#include <iostream>
using namespace std;

int main() {
    int k, ans = 0;
    cin >> k;
    for (int i = 1, t = 1;; i++)
        for (int j = 1; j <= i; j++) {
            t++;
            ans += i;
            if (t == k + 1) {
                cout << ans;
                return 0;
            }
        }
    return 0;
}
~~~



### 11. 玩具谜题

**题目描述**

小南有一套可爱的玩具小人，它们各有不同的职业。有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：

![img](http://ybt.ssoier.cn:8088/pic/1893a.jpg)

这时singer告诉小南一个谜题：“眼镜藏在我左数第3个玩具小人的右数第1个玩具小人的左数第2个玩具小人那里。”

小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。

 小南一边艰难地辨认着玩具小人，一边数着：

 “singer朝内，左数第3个是archer。

 “archer朝外，右数第1个是thinker。

 “thinker朝外，左数第2个是writer。

 “所以眼镜藏在writer这里！”

虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：

有n个玩具小入围成一圈，己知它们的职业和朝向。现在第1个玩具小人告诉小南一个包含m条指令的谜题，其中第i条指令形如“左数/右数第$S_i$个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。

**输入格式**

输入的第一行包含两个正整数n，m，表示玩具小人的个数和指令的条数。

接下来n行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中0表示朝向圈内，1表示朝向圈外。保证不会出现其他的数。字符串长度不超过10且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来m行，其中第i行包含两个整数$a_i$，$S_i$，表示第i条指令。若$a_i$=0，表示向左数$S_i$个人；若$a_i$=1，表示向右数$S_i$个人。保证ai不会出现其他的数，$1<S_i<n$。

**输出格式**

输出一个字符串，表示从第一个读入的小人开始，依次数完m条指令后到达的小人的职业。

**输入样例**

```c++
7 3 
0 singer 
0 reader 
0 mengbier 
1 thinker 
1 archer 
0 writer 
1 mogician 
0 3 
1 1 
0 2
```

【输出样例】

```c++
writer
```

**输入样例2**

```c++
10 10 
1 c 
0 r 
0 p 
1 d 
1 e 
1 m 
1 t 
1 y 
1 u 
0 v 
1 7 
1 1 
1 4 
0 5 
0 3 
0 1 
1 6 
1 2 
0 8 
0 4
```

**样例2输出**

```c++
y
```

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表：

![img](http://ybt.ssoier.cn:8088/pic/1893b.jpg)

其中一些简写的列意义如下：

- 全朝内：若为“√”，表示该测试点保证所有的玩具小人都朝向圈内；
- 全左数：若为“√”，表示该测试点保证所有的指令都向左数，即对任意的 1<i<m, ai=0;
- Si=1：若为“√”，表示该测试点保证所有的指令都只数1个，即对任意的 1≤i≤m，  Si=1；
- 职业长度为1：若为“√”，表示该测试点保证所有玩具小人的职业一定是一个 长度为1的字符串。

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int n, m;
struct node {
    int f;
    char s[15];
} a[100005];

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> a[i].f >> a[i].s;
    int idx = 0;
    while (m--) {
        int x, y;
        cin >> x >> y;
        if (x == 0 && a[idx].f == 0 || x == 1 && a[idx].f == 1)
            idx = (idx - y + n) % n;
        else if (x == 0 && a[idx].f == 1 || x == 1 && a[idx].f == 0)
            idx = (idx + y) % n;
    }
    cout << a[idx].s;
    return 0;
}
~~~



### 12. 时间复杂度（2017）

**题目描述**

给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序，于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 

$A++$ 语言的循环结构如下：

```c++
F i x y
	循环体
E
```

然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。 

$x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 $100$。 

$E$ 表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。

注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 $O$ 表示通常意义下 $Θ$ 的概念。

**输入格式**

第一行一个正整数 $t$，表示有 $t(t≤10)$ 个程序需要计算时间复杂度。每个程序我们只需抽取其中 `F i x y​`$ 和 $$E$ 即可计算时间复杂度。注意：循环结构允许嵌套。

接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，$O(1)$ 表示常数复杂度，$O(n^w)$ 表示复杂度为 $n^w$，其中 $w$ 是一个小于 $100$ 的正整数（输入中不包含引号），输入保证复杂度只有 $O(1)$ 和 $O(n^w)$ 两种类型。

接下来 $L$ 行代表程序中循环结构中的 `F i x y​` 或者 $E$。 程序行若以 $F$ 开头，表示进入一个循环，之后有空格分离的三个字符（串）`i x y`，其中 $i$ 是一个小写字母（保证不为 $n$ ），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 $100$。 

程序行若以 $E$ 开头，则表示循环体结束。

**输出格式**

输出共 $t$ 行，对应输入的 $t$ 个程序，每行输出 $Yes$ 或 $No$ 或者 $ERR$，若程序实际复杂度与输入给出的复杂度一致则输出 $Yes$，不一致则输出$No$，若程序有语法错误（其中语法错误只有: ① $F$ 和 $E$ 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出$ERR$。注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出$ERR$。
【输入样例】

```c++
8  
2 O(1)  
F i 1 1  
E  2 O(n^1)  
F x 1 n  
E 
1 O(1)  
F x 1 n  
4 O(n^2)  
F x 5 n  
F y 10 n  
E  
E  
4 O(n^2)  
F x 9 n  
E 
F y 2 n  
E  
4 O(n^1)  
F x 9 n  
F y n 4  
E  
E  
4 O(1)  
F y n 4  
F x 9 n  
E  
E  
4 O(n^2) 
F x 1 n  
F x 1 10  
E  
E
```

**输出样例**

```c++
Yes
Yes
ERR
Yes
No
Yes
Yes
ERR
```

**样例说明**

第一个程序 $i$ 从$1$ 到 $1$ 是常数复杂度。

第二个程序 $x$ 从 $1$ 到 $n$ 是 $n$ 的一次方的复杂度。

第三个程序有一个 $F$ 开启循环却没有E结束，语法错误。

第四个程序二重循环，$n$ 的平方的复杂度。

第五个程序两个一重循环，$n$ 的一次方的复杂度。

第六个程序第一重循环正常，但第二重循环开始即终止（因为 $n$ 远大于 $100$，$100$ 大于 $4$）。

第七个程序第一重循环无法进入，故为常数复杂度。

第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 $ERR$。

**数据范围**

对于 30% 的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 $F$ 开头的语句，第 $L/2+1$ 行至第 $L$行一定为以 $E$ 开头的语句，$L≤10$，若 $x$,$y$ 均为整数，$x$一定小于 $y$，且只有 $y$ 有可能为 $n$。

对于 50% 的数据：不存在语法错误，$L≤100$，且若 $x$ , $y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。

对于 70% 的数据：不存在语法错误，$L≤100$。

对于 100% 的数据：$t≤10,L≤100$。



## II 枚举算法

### 1. 数字统计（2010）

**题目描述**

请统计某个给定范围[L, R]的所有整数中，数字2 出现的次数。

比如给定范围[2, 22]，数字2 在数2 中出现了1 次，在数12 中出现1 次，在数20 中出现1 次，在数21 中出现1 次，在数22 中出现2 次，所以数字2 在该范围内一共出现了6次。

**输入数据**

共1 行，为两个正整数L 和R，之间用一个空格隔开。

**输出数据**

共1 行，表示数字2 出现的次数。

**输入样例**

```c++
2 22
```
**输出样例**

```c++
6
```

**输入样例2**

```c++
2 100
```

**输出样例2**

```c++
20
```
**数据范围**
$1 ≤ L ≤ R≤ 10000$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;

int main() {
    int l, r;
    cin >> l >> r;
    int ans = 0;
    for (int i = l; i <= r; i++) {
        int t = i;
        while (t) {
            if (t % 10 == 2) ans++;
            t /= 10;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 2. 导弹拦截（2010）

**题目描述**

经过11 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为0 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

**输入数据**

第一行包含4 个整数$x_1、y_1、x_2、y_2$，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为$(x_1, y_1)、(x_2, y_2)$。

第二行包含1 个整数N，表示有N 颗导弹。接下来N 行，每行两个整数x、y，中间用一个空格隔开，表示一颗导弹的坐标(x, y)。不同导弹的坐标可能相同。

**提示**

两个点$(x_1, y_1)、(x_2, y_2)$之间距离的平方是$(x_1− x_2)^2+(y_1−y_2)^2$。

两套系统工作半径$r_1、r_2$ 的平方和，是指$r_1、r_2$ 分别取平方后再求和，即$r_1^2+r_2^2$。

**输出数据**

只有一行，包含一个整数，即当天的最小使用代价。

**输入样例**

~~~c++
0 0 10 0 
2
-3 3
10 0
~~~

**输出样例**

~~~c++
18
~~~

**样例 1 说明**
样例1 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为18 和0。

**输入样例2**

~~~c++
0 0 6 0 
5 
-4 -2 
-2 3 
4 0 
6 -2 
9 1
~~~

**输出样例2**

~~~c++
30
~~~

**样例2 说明**

样例中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为20 和10。

![img](http://ybt.ssoier.cn:8088/pic/1951.gif)
**数据范围**

对于10%的数据，N = 1

对于20%的数据，1 ≤ N ≤ 2

对于40%的数据，1 ≤ N ≤ 100

对于70%的数据，1 ≤ N ≤ 1000

对于100%的数据，1 ≤ N ≤ 100000，且所有坐标分量的绝对值都不超过1000。

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
const int N = 100005;

struct node {
    int x, y, d1, d2;
} a[N];

bool cmp(node a, node b) { return a.d1 > b.d1; }

int main() {
    int x1, y1, x2, y2, n;
    cin >> x1 >> y1 >> x2 >> y2;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y;
        a[i].d1 = (a[i].x - x1) * (a[i].x - x1) + (a[i].y - y1) * (a[i].y - y1);
        a[i].d2 = (a[i].x - x2) * (a[i].x - x2) + (a[i].y - y2) * (a[i].y - y2);
    }
    sort(a + 1, a + n + 1, cmp);
    int ans = a[1].d1, k = 0;
    for (int i = 2; i <= n; i++) {
        k = max(k, a[i - 1].d2);
        ans = min(ans, a[i].d1 + k);
    }
    k = max(k, a[n].d2);
    ans = min(ans, k);
    cout << ans;
    return 0;
}
~~~



### 3. 质因数分解(2012)

**题目描述**

已知正整数 n 是两个不同的质数的乘积，试求出较大的那个质数。

**输入数据**

输入只有一行，包含一个正整数 n。

**输出数据**

输出只有一行，包含一个正整数 p，即较大的那个质数。

**输入样例**

```c++
21
```

**输出样例**

```c++
7
```

**数据范围**

对于 60%的数据，$6 ≤ n ≤ 1000$。

对于 100%的数据，$6 ≤ n ≤ 2*10^9$。

**解题思路**

- 时间复杂度：$O(\sqrt{n})$

~~~c++
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++)
        if (n % i == 0) {
            cout << n / i;
            return 0;
        }
    return 0;
}
~~~



### 4. 计数问题(2013)

**题目描述**

试计算在区间 1 到 n 的所有整数中，数字 $x（0≤x≤9）$共出现了多少次？例如，在 1 到 11 中，即在 1、2、3、4、5、6、7、8、9、10、11 中，数字 1 出现了 4 次。

**输入数据**

输入共 1 行，包含 22 个整数 $n、x$ 之间用一个空格隔开。

**输出数据**

输出共 1 行，包含一个整数，表示 x 出现的次数。

**输入样例**

```c++
11 1
```
**输出样例**

```c++
4
```

**数据说明**

对于 100%的数据，$1≤n≤1,000,000，0≤x≤9$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;

int main() {
    int n, x;
    cin >> n >> x;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int t = i;
        while (t) {
            if (t % 10 == x) ans++;
            t /= 10;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 5. 珠心算测验（2014）

**题目描述**

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。

某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？

最近老师出了一些测验题，请你帮忙求出答案。

**输入数据**

输入共两行，第一行包含一个整数 n，表示测试题中给出的正整数个数。

第二行有 n 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。

**输出数据**

输出共一行，包含一个整数，表示测验题答案。

**输入样例**

```c++
4 
1 2 3 4
```

**输出样例**

```c++
2
```

**样例说明**

由 1+2=3，1+3=4，故满足测试要求的答案为 2。注意，加数和被加数必须是集合中的两个不同的数。

**数据说明**

对于 100%的数据，3  ≤  n  ≤  100，测验题给出的正整数大小不超过 10,000。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
int n, a[101], f[20005];
int main() {
    int ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i < n; i++)
        for (int j = i + 1; j <= n; j++) f[a[i] + a[j]] = 1;  //避免重复计算
    for (int i = 1; i <= n; i++) ans += f[a[i]];
    cout << ans;
    return 0;
}
~~~



### 6. 比例简化（2014）

**题目描述**

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 1498 人，反对的有 902 人，那么赞同与反对的比例可以简单的记为$1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 A，反对人数 B，以及一个上限 L，请你将 A 比 B 化简为 A’比 B’，要求在 A’和 B’均不大于 L 且 A’和 B’互质（两个整数的最大公约数是 1）的前提下，A’/B’ ≥ A/B且 A’/B’ - A/B 的值尽可能小。

**输入格式**

输入共一行，包含三个整数 A，B，L，每两个整数之间用一个空格隔开，分别表示支持人数、反对人数以及上限。

**输出格式**

输出共一行，包含两个整数 A’，B’，中间用一个空格隔开，表示化简后的比例。

**输入样例**

~~~c++
1498 902 10
~~~

**输出样例**

~~~c++
5 3
~~~

**数据说明**

对于 100%的数据，1  ≤  A  ≤  1,000,000，1  ≤  B  ≤  1,000,000，1  ≤  L  ≤  100， A/B  ≤  L。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
int A, B, L;

int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

int main() {
    cin >> A >> B >> L;
    int a, b;
    double mi = 1e9;
    for (int i = 1; i <= L; i++)
        for (int j = 1; j <= L; j++)
            if (gcd(i, j) == 1 && i * 1.0 / j >= A * 1.0 / B) {
                double t = i * 1.0 / j - A * 1.0 / B;
                if (mi > t) {
                    a = i;
                    b = j;
                    mi = t;
                }
            }
    cout << a << " " << b;
    return 0;
}
~~~



### 7. 扫雷游戏(2015)

**题目描述**

扫雷游戏是一款十分经典的单机小游戏。在n行m列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出 n 行 m 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。

**输入格式**

第一行是用一个空格隔开的两个整数 n 和 m ，分别表示雷区的行数和列数。

接下来 n 行，每行 m 个字符，描述了雷区中的地雷分布情况。字符’`*`’表示相应格子是地雷格，字符’`?`’表示相应格子是非地雷格。相邻字符之间无分隔符。

**输出格式**

包含 n 行，每行 m 个字符，描述整个雷区。用’`*`’表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。

**输入样例**

```c++
3 3 
*?? 
??? 
?*?
```

**输出样例**

```c++
*10 
221 
1*1
```

**输入样例2**

```c++
2 3 
?*? 
*??
```

**输出样例1**

```c++
2*1 
*21
```

对于 100%的数据， $1≤n≤100，1≤m≤100$。

**解题思路**

~~~c++
#include <bits/stdc++.h>
using namespace std;
const int dr[8][2] = {{1, 0}, {0, 1}, { -1, 0}, {0, -1}, {1, 1}, { -1, 1}, {1, -1}, { -1, -1}};
int n, m;
char mp[105][105];

int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			cin >> mp[i][j];
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(mp[i][j] == '?') {
				int cnt = 0;
				for(int k = 0; k < 8; k++) {
					int nx = i + dr[k][0];
					int ny = j + dr[k][1];
					if(mp[nx][ny] == '*')
						cnt++;
				}
				mp[i][j] = cnt + '0';
			}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++)
			cout << mp[i][j];
		cout << endl;
	}
	return 0;
}
~~~



### 8. 回文日期（2016）

**题目描述**

日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。显然:一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。现在，牛牛想知道:在他指定的两个日期之间(包含这两个日期本身)，有多少个真实存在的日期是回文的。

**提示**

一个 8 位数字是回文的，当且仅当对于所有的$i(1<i<8)$从左向右数的第 i 个数字和第$9−i$个数字(即从右向左数的第 i 个数字)是相同的。

例如:

- 对于2016年11月19日，用8位数字20161119表示，它不是回文的。

- 对于2010年1月2日，用8位数字20100102表示，它是回文的。

- 对于2010年10月2日，用8位数字20101002表示，它不是回文的。

每一年中都有12个月份：

其中：

- 1 , 3 , 5 , 7 , 8 , 10 , 12月每个月有31天
- 4 , 6 , 9 , 11 月每个月有30天
- 而对于 2 月，闰年时有 29 天，平年时有 28 天

一个年份是闰年当且仅当它满足下列两种情况其中的一种:

- 这个年份是4的整数倍，但不是100的整数倍;

- 这个年份是400的整数倍。

例如:

- 以下几个年份都是闰年:2000 ,2012 ,2016

- 以下几个年份是平年:1900,2011,2014

**输入格式**

输入包括两行，每行包括一个8位数字。

第一行表示牛牛指定的起始日期date1

第二行表示牛牛指定的终止日期date2

保证date1和date2都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。

保证date1一定不晚于date2。

**输出格式**

输出一行，包含一个整数，表示在date1和date2之间，有多少个日期是回文的。

**输入样例**

~~~c++
20110101 
20111231
~~~

**输出样例** 

~~~c++
1
~~~

**样例输入2** 

~~~c++
20000101 
20101231
~~~

**样例输出2**

~~~c++
2
~~~

**提示**

对于样例1，符合条件的日期是20111102

对于样例2，符合条件的日期是20011002和20100102

对于60%的数据，满足date1=date2。

**解题思路**

~~~c++
#include <iostream>
using namespace std;

int d[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int work(int x) {
    int res = 0;
    while (x) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return res;
}

bool ck(int y) {
    if (y % 4 == 0 && y % 100 != 0 || y % 400 == 0)
        return true;
    else
        return false;
}

int main() {
    int ans = 0;
    int data1, data2;
    cin >> data1 >> data2;
    int year1 = data1 / 10000, year2 = data2 / 10000;
    for (int y = year1; y <= year2; y++) {
        int k = work(y);
        int month = k / 100;
        int day = k % 100;
        if (month > 12 || month < 1) continue;
        if (day > d[month] || day < 1) continue;
        if (month == 2 && ck(y) != true && day == 29) continue;
        ans++;
    }
    cout << ans;
    return 0;
}
~~~



## III 字符串处理

### 1. 乒乓球（2008）

**题目描述**

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：

WWWWWWWWWWWWWWWWWWWWWWLW

在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。

你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。

**输入格式**

每个输入包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。

**输出格式**

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

**输入样例**

```c++
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

**输出样例**

```c++
11:0 
11:0 
1:1 
21:0 
2:1
```

**解题思路**

~~~c++
#include <iostream>
using namespace std;

string s;
void work(int x) {
    int a = 0, b = 0;
    int len = s.size();
    for (int i = 0; i < len && s[i] != 'E'; i++) {
        if (s[i] == 'W')
            a++;
        else if (s[i] == 'L')
            b++;
        if (max(a, b) >= x && abs(a - b) >= 2) {  //最高分大于x 且差值大于等于2
            cout << a << ":" << b << endl;
            a = 0, b = 0;
        }
    }
    cout << a << ":" << b << endl;
}

int main() {
    string t;
    while (cin >> t) s += t;
    work(11);
    cout << endl;
    work(21);
    return 0;
}
~~~



### 2.  ISBN号码（2008）

**题目描述**

每一本正式出版的图书都有一个ISBN号码与之对应,ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”,其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语音，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔符之后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN码0-670-82162-4中的识别码4是这样得到的：对0670082162这9个数字，从左至右，分别乘以1，2，…9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码/

你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出你认为是正确的ISBN号码。

**输入格式**

只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码，的格式要求）。

**输出格式**

一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。

**输入样例**

```c++
0-670-82162-4
```

**输出样例**

```c++
Right
```

**输入样例2**

```c++
0-670-82162-0
```

**输出样例2**

```c++
0-670-82162-4
```

**解题思路**

~~~c++
#include <iostream>
using namespace std;

int main() {
    char s[20];
    int i = 0, j = 1, sum = 0;
    cin >> s;
    while (i <= 10) {
        if (s[i] >= '0' && s[i] <= '9') {
            sum += (s[i] - '0') * j;
            j++;
        }
        i++;
    }

    char c = 'X';
    if (sum % 11 != 10) c = sum % 11 + '0';
    if (s[12] == c)
        puts("Right");
    else {
        s[12] = c;
        puts(s);
    }
    return 0;
}
~~~



### 3. 多项式输出（2009）

**题目描述**

一元 $n$ 次多项式可用如下的表达式表示：

$f(x)=a_nx^n+a_{n−1}x^{n−1}+...+a_1x+a_0，a_n≠0$

其中，$a_ix_i$称为$i$次项，$a_i$称为 $i$ 次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：

1. 多项式中自变量为$x$，从左到右按照次数递减顺序给出多项式。

2. 多项式中只包含系数不为$0$的项。

3. 如果多项式$n$次项系数为正，则多项式开头不出现“$+$”号，如果多项式$n$次项系数为负，则多项式以“$−$”号开头。

4. 对于不是最高次的项，以“$+$”号或者“$−$”号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于$0$次的项，其系数的绝对值为$1$，则无需输出$1$）。如果$x$的指数大于$1$，则接下来紧跟的指数部分的形式为“$x∧b$”，其中$b$为$x$的指数；如果$x$的指数为$1$，则接下来紧跟的指数部分形式为“$x$”；

如果$x$的指数为$0$，则仅需输出系数即可。

5. 多项式中，多项式的开头、结尾不含多余的空格。

**输入格式** 

共有2 行

第一行 $1$ 个整数，$n$，表示一元多项式的次数。

第二行有 $n+1$ 个整数，其中第$i$个整数表示第$n−i+1$ 次项的系数，每两个整数之间用空格隔开。

**输出格式** 

共 1 行，按题目所述格式输出多项式。

**输入样例**

~~~c++
5 
100 -1 1 -3 0 10
~~~

**输出样例**

~~~c++
100x^5-x^4+x^3-3x^2+10
~~~

**输入样例2**

~~~c++
3 
-50 0 0 1
~~~

**输出样例2**

~~~c++
-50x^3+1
~~~

**数据范围**
$1≤n≤100$，多项式各次项系数的绝对值均不超过100。

**解决思路**

~~~c++
#include <cmath>
#include <iostream>
using namespace std;

int main() {
    int n, t;
    cin >> n;
    for (int i = n; i >= 0; i--) {
        cin >> t;
        if (t == 0) continue;
        if (i != n && t > 0)
            cout << "+";
        else if (t < 0)
            cout << "-";
        t = abs(t);
        if (i != 0 && t != 1)
            cout << t;
        else if (i == 0)
            cout << t;
        if (i != 0) cout << "x";
        if (i > 1) cout << "^" << i;
    }
    return 0;
}
~~~



### 4. 立体图（2008）

**题目描述**

小渊是个聪明的孩子，他经常会给周围的小朋友讲些自己认为有趣的内容。最近，他准备给小朋友讲解立体图，请你帮他画出立体图。

小渊有一块面积为m*n的矩形区域，上面有m*n个边长为1的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是1），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以一种形式摆放。

```c++
  +---+
 /   /|高
+---+ |
|   | +
|   |/宽
+---+
 长
```

每个顶点用1个加号"+"表示,长用3个"-"表示,宽用1个"/"表示,高用两个"|"表示。符号"+","-","/","|"的ASCII码分别是43,45,47,124。字符"."(ASCII码46)需要作为背景输出，即立体图中的空白部分需要用"."来代替。立体图的画法如下面的规则：

若两块积木左右相邻，图示为：

~~~c++
..+---+---+
./   /   /|
+---+---+ |
|   |   | +
|   |   |/.
+---+---+..
~~~

若两块积木上下相邻，图示为：

~~~c++
..+---+
./   /|
+---+ |
|   | +
|   |/|
+---+ |
|   | +
|   |/.
+---+..
~~~

若两块积木前后相邻，图示为：

~~~c++
....+---+
.../   /|
..+---+ |
./   /| +
+---+ |/.
|   | +..
|   |/...
+---+....
~~~

立体图中，定义位于第(m,1)的格子（即第m行第1列的格子）上面的自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。

**输入格式**

第一行有用空格隔开的2个整数m和n，表示有$m*n$个格子（1≤m,n≤50)。接下来的m行，是一个$m*n$的矩阵，每行有n个用空格隔开的整数，其中第i行第j列上的整数表示第i行第j列的格子上摞有多少个积木（1≤每个格子上的积木数≤100)。

**输出格式**

包含题目要求的立体图，是一个K行L列的字符矩阵，其中K和L表示最少需要K行L列才能按规定输出立体图。

**输入样例**

~~~c++
3 4
2 2 1 2
2 2 1 1
3 2 1 2
~~~

**输出样例**

~~~c++
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
~~~

**解题思路**

~~~c++

~~~



## IV 排序算法

### 1. 明明的随机数（2006）

**题目描述**

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

**输入格式**

有2行，第1行为1个正整数，表示所生成的随机数的个数：N

第2行有N个用空格隔开的正整数，为所产生的随机数。

**输出格式**

2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

**输入样例**

```c++
10 
20 40 32 67 40 20 89 300 400 15
```

**输出样例**

```c++
8 
15 20 32 40 67 89 300 400
```

**解题思路**

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
int n, a[105];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    n = unique(a + 1, a + n + 1) - a - 1;
    cout << n << endl;
    for (int i = 1; i <= n; i++) cout << a[i] << " ";
    return 0;
}
~~~



### 2. 奖学金（2007）

**题目描述**

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 5 名学生发奖学金。期末，每个学生都有 3 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。

任务：先根据输入的 3 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 5 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是：

```c++
7 279 
5 279
```

这两行数据的含义是:总分最高的两个同学的学号依次是 7 号、5 号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和)，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是:

```c++
5 279 
7 279
```

则按输出错误处理，不能得分。

**输入格式**

第1行为一个正整数 n ，表示该校参加评选的学生人数。第2到 n+1 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到 100 之间。第jj行的 3 个数字依次表示学号为 j−1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 l∼n  (恰好是输入数据的行号减 1 )。所给的数据都是正确的，不必检验。

**输出格式**

共有5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。

**输入样例**

```c++
6 
90 67 80 
87 66 91 
78 89 91 
88 99 77 
67 89 64 
78 89 98
```

**输出样例**

```c++
6 265 
4 264 
3 258 
2 244 
1 237
```

**输入样例2**

```c++
8  
80 89 89  
88 98 78  
90 67 80  
87 66 91  
78 89 91  
88 99 77  
67 89 64  
78 89 98
```
**输出样例2**

```c++
8 265 
2 264  
6 264  
1 258  
5 258
```

**限制**

50%的数据满足：各学生的总成绩各不相同；

100%的数据满足：$6≤n≤300$。

**解题思路**

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
const int N = 205;
struct node {
    int xh, yw, sx, yy, zf;
    bool operator<(const node &b) const {
        if (zf > b.zf) return true;
        if (zf == b.zf && yw > b.yw) return true;
        if (zf == b.zf && yw == b.yw && xh < b.xh) return true;
        return false;
    }
} a[N];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].yw >> a[i].sx >> a[i].yy;
        a[i].zf = a[i].yw + a[i].sx + a[i].yy;
        a[i].xh = i;
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= 5; i++) cout << a[i].xh << " " << a[i].zf << endl;
    return 0;
}
~~~



### 3. 分数线划定

**题目描述**

世博会志愿者的选拔工作正在A市如火如荼的进行。为了选拔最合适的人才，A市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的150%划定，即如果计划录取m名志愿者，则面试分数线为排名第$m*150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

**输入格式**

第一行，两个整数 n，m（5 ≤ n ≤ 5000，3 ≤ m ≤ n），中间用一个空格隔开，其中n 表示报名参加笔试的选手总数，m 表示计划录取的志愿者人数。输入数据保证$m*150\%$向下取整后小于等于n。

第二行到第 n+1 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号k（1000 ≤ k ≤ 9999）和该选手的笔试成绩s（1 ≤ s ≤ 100）。数据保证选手的报名号各不相同。

**输出格式**

第一行，有两个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。

从第二行开始，每行包含两个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。

**输入样例**

```c++
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88
```

【输出样例】

```c++
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88
```

【样例说明】
$m*150% = 3*150% = 4.5$，向下取整后为4。保证4 个人进入面试的分数线为88，但因为88有重分，所以所有成绩大于等于88 的选手都可以进入面试，故最终有5 个人进入面试。

**解题思路**

~~~c++
#include <algorithm>
#include <cmath>
#include <iostream>
using namespace std;
int n, m;
struct node {
    int k, s;
    bool operator<(const node b) const {
        if (s == b.s) return k < b.k;
        return s > b.s;
    }
} a[5005];
int main() {
    cin >> n >> m;
    m = floor(m * 1.5);
    for (int i = 1; i <= n; i++) cin >> a[i].k >> a[i].s;
    sort(a + 1, a + n + 1);
    int score = a[m].s;
    int cnt = 0;
    for (int i = 1; i <= n; i++)
        if (a[i].s >= score) cnt++;
    cout << score << " " << cnt << endl;
    for (int i = 1; i <= cnt; i++) cout << a[i].k << " " << a[i].s << endl;
    return 0;
}
~~~



### 4. 瑞士轮（2011）

**题目描述**

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于 1895 年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。

$2*N$ 名编号为 $1 \sim 2N$ 的选手共进行 $R$ 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第 $1$ 名和第 $2$ 名、第 $3$ 名和第 $4$ 名、……、第 $2K – 1$ 名和第$2K$名、…… 、第 $2N – 1$ 名和第 $2N$ 名，各进行一场比赛。每场比赛胜者得 $1$ 分，负者得 $0$ 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

**输入格式**

第一行是三个正整数 $N、R、Q$，每两个数之间用一个空格隔开，表示有 $2*N$ 名选手、$R$ 轮比赛，以及我们关心的名次 $Q$。

第二行是 $2*N$ 个非负整数 $s_1, s_2, …, s_{2N}$，每两个数之间用一个空格隔开，其中 $s_i$ 表示编号为i 的选手的初始分数。

第三行是 $2*N$ 个正整数 $w_1, w_2, …, w_{2N}$，每两个数之间用一个空格隔开，其中 $w_i$ 表示编号为 $i$ 的选手的实力值。

**输出格式**

只有一行，包含一个整数，即 $R$ 轮比赛结束后，排名第 $Q$ 的选手的编号。

**输入样例**
```c++
2 4 2 
7 6 6 7 
10 5 20 15
```

**输出样例**

```c++
1
```

**输入输出样例说明**

|          | 本轮对阵  | 得分 |      |      |      |
| -------- | --------- | ---- | ---- | ---- | ---- |
| 选手编号 | /         | ①    | ②    | ③    | ④    |
| 初始     | /         | 7    | 6    | 6    | 7    |
| 第1轮    | ①--④ ②--③ | 7    | 6    | 7    | 8    |
| 第2轮    | ④--① ③--② | 7    | 6    | 8    | 9    |
| 第3轮    | ④--③ ①--② | 8    | 6    | 9    | 9    |
| 第4轮    | ③--④ ①--② | 9    | 6    | 10   | 9    |

**数据范围**

对于 30%的数据：$1 ≤ N≤ 100$；

对于 50%的数据：$1 ≤ N≤ 10,000$；

对于 100%的数据：$1 ≤ N≤ 100,000$，$1 ≤ R≤ 50$，$1 ≤ Q≤ 2N$，

​                                 $0 ≤ s_1, s_2, …, s_{2N} ≤ 10^8$，$1 ≤ w_1,w_2, …, w_{2N} ≤ 10^8$。

**解题思路**

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;

const int N = 200005;
int n, r, q;

struct node {
    int k, s, w;
    bool operator<(const node &b) {
        if (s == b.s && k < b.k) return true;
        if (s > b.s) return true;
        return false;
    }
} a[N];

int main() {
    cin >> n >> r >> q;
    for (int i = 1; i <= 2 * n; i++) cin >> a[i].s, a[i].k = i;
    for (int i = 1; i <= 2 * n; i++) cin >> a[i].w;
    do {
        sort(a + 1, a + 2 * n + 1);
        for (int i = 1; i <= 2 * n; i += 2) {
            if (a[i].w > a[i + 1].w)
                a[i].s++;
            else
                a[i + 1].s++;
        }
    } while (r--);
    cout << a[q].k;
    return 0;
}
~~~



## V 数学

### 1. 麦森数（2003）

**题目描述**

形如$2^P-1$的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^P-1$不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 P = 3021377，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。

任务：输入 P（1000＜P＜3100000），计算 $2^P-1$的位数和最后500位数字(用十进制高精度数表示)

**输入格式**

只包含一个整数 P（1000＜P＜3100000）

**输出格式**

第一行：十进制高精度数 $2^P-1$的位数。

第2-11行：十进制高精度数$2^P-1$的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0）

不必验证$2^P-1$与 $P$ 是否为素数。

**输入样例**

```c++
1279
```


**输出样例**

```c++
386 
00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000 00000000000000104079321946643990819252403273640855 38615262247266704805319112350403608059673360298012 23944173232418484242161395428100779138356624832346 49081399066056773207629241295093892203457731833496 61583550472959420547689811211693677147548478866962 50138443826029173234888531116082853841658502825560 46662248318909188018470682222031405210266984354887 32958028878050869736186900714720710555703168729087
```

**解题思路**

~~~c++
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 510;
int a[N], ans[N];

void mul(int res[], int x[], int y[]) {
    int c[N];
    memset(c, 0, sizeof(c));
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (i + j < N) c[i + j] += x[i] * y[j];

    int t = 0;
    for (int i = 0; i < N; i++) {
        t = t + c[i];
        res[i] = t % 10;
        t = t / 10;
    }
}

void qmi(int p) {
    a[0] = 2;
    ans[0] = 1;
    while (p) {
        if (p & 1) mul(ans, ans, a);
        mul(a, a, a);
        p >>= 1;
    }
}

int main() {
    int p;
    cin >> p;
    cout << int(p * log10(2) + 1) << endl;
    qmi(p);
    ans[0]--;
    for (int i = 0, k = 499; i < 10; i++) {
        for (int j = 0; j < 50; j++, k--) cout << ans[k];
        cout << endl;
    }
    return 0;
}
~~~



### 2. 循环