# 普及组真题训练
## I 模拟算法
### 1. 不高兴的津津（2004）
**题目描述**

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

**数据输入**

包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

**数据输出**

一行，这一行只包含一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

**输入样例**

~~~c++
5 3
6 2
7 2
5 3
5 4
0 4
0 6
~~~

**输出样例**

~~~c++
3
~~~

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

~~~c#
#include <iostream>
using namespace std;
int main() {
    int mx = 0, ans = 0;
    for (int i = 1; i <= 7; i++) {
        int x, y;
        cin >> x >> y;
        if (x + y > 8 && mx < x + y) 
            mx = x + y, ans = i;
    }
    cout << ans;
    return 0;
}
~~~



### 2. 花生采摘(2004)

**题目描述**

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图1）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![img](http://ybt.ssoier.cn:8088/pic/1927.jpg)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2. 从一棵植株跳到前后左右与之相邻的另一棵植株；
3. 采摘一棵植株下的花生；
4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于$(2,5),(3,7),(4,2),(5,4)(2,5),(3,7),(4,2),(5,4)$的植株下长有花生，个数分别为$13,7,15,913,7,15,9$。沿着图示的路线，多多在$21$个单位时间内，最多可以采到$37$个花生。

**输入数据**

第一行包括三个整数，$M$, $N$和$K$，用空格隔开；表示花生田的大小为$M×N(1≤M,N≤20)$，多多采花生的限定时间为$K(0≤K≤1000)$个单位时间。接下来的$M$行，每行包括$N$个非负整数，也用空格隔开；第$i+1$行的第$j$个整数$P_{ij}(0≤P_{ij}≤500)$表示花生田里植株$(i,j)$下花生的数目，$0$表示该植株下没有花生。

**输出数据**

一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。

**输入样例**

```c++
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```
**输出样例**

```c++
37
```
**样例输入2**
```c++
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```
**样例输出2**

```c++
28
```

**解题思路**

- 时间复杂度：$O(n*m)$
- 空间复杂度：$O(n*m)$

~~~c++
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, k, cnt;
const int N = 20 * 20 + 5;
struct node {
    int x, y, w;
} a[N];

bool cmp(node a, node b) { return a.w > b.w; }

int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            int t;
            cin >> t;
            if (t > 0) {
                cnt++;
                a[cnt].x = i, a[cnt].y = j, a[cnt].w = t;
            }
        }
    sort(a + 1, a + cnt + 1, cmp);
	//初始位置信息
    int xx = 0, yy = a[1].y, ans = 0;
    for (int i = 1; i <= cnt; i++) {
        int dis = abs(xx - a[i].x) + abs(yy - a[i].y);
        if (k >= dis + a[i].x + 1) {  //判断是否能完成采摘
            ans += a[i].w;
            k -= dis + 1;
            //更新位置信息
            xx = a[i].x;
            yy = a[i].y;
            continue;
        }
        break;  //如果无法摘到剩余的最大值，则直接退出 （第一次写的时候忽略了这个点）
    }
    cout << ans;
    return 0;
}
~~~



### 3. 陶陶摘苹果（2005）

**题目描述**

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。

现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。

**输入数据**

两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。

**输出数据**

一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。

**输入样例**

```c++
100 200 150 140 129 134 167 198 200 111 
110
```
**输出样例**
```C++
5
```

**解题思路**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int a[11], h;
int main() {
    for (int i = 1; i <= 10; i++) cin >> a[i];
    cin >> h;
    int ans = 0;
    for (int i = 1; i <= 10; i++)
        if (a[i] <= h + 30) ans++;
    cout << ans;
    return 0;
}
~~~



### 4. 校门外的树（2005）

**题目描述**

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。

由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

**输入数据**

第一行有两个整数L（1 ≤ L ≤ 10000）和 M（1 ≤ M ≤ 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。

**输出数据**

一行，这一行只包含一个整数，表示马路上剩余的树的数目。

**输入样例**
```c++
500 3 
150 300 
100 200 
470 471
```

**输出样例**
```c++
298
```

**提示**
- 对于20%的数据，区域之间没有重合的部分；
- 对于其它的数据，区域之间有重合的情况；

**解题思路**

- 时间复杂度：$O(n)$

- 空间复杂度：$O(n)$

~~~c++
#include <iostream>
using namespace std;
int L, m;
bool t[10005];
int main() {
    cin >> L >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        for (int j = x; j <= y; j++) t[j] = true;
    }
    int ans = 0;
    for (int i = 0; i <= L; i++)
        if (!t[i]) ans++;
    cout << ans;
    return 0;
}
~~~



### 4. 接水问题（2010）

**题目描述**

学校里有一个水房，水房里一共装有$m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为$1$。

现在有$n$名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从$1$到$n$编号，$i$号同学的接水量为$w_i$。接水开始时，$1$到$m$号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学$j$完成其接水量要求$w_j$ 后，下一名排队等候接水的同学$k$马上接替$j$同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即$j$同学第$x$秒结束时完成接水，则$k$同学第$x+1$秒立刻开始接水。若当前接水人数$n^′$不足$m$，则只有$n^′$个龙头供水，其它$m−n^′$个龙头关闭。

现在给出$n$名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

**输入数据**

第1 行2 个整数$n$和$m$，用一个空格隔开，分别表示接水人数和龙头个数。

第2 行n 个整数$w_1、w_2、……、w_n$，每两个整数之间用一个空格隔开，$wi$表示$i$号同学的接水量。

**输出数据**

只有一行，$1$个整数，表示接水所需的总时间。

**输入样例**

```c++
5 3 
4 4 1 2 1
```

**输出样例**
```c++
4 
```
**输入输出样例说明**

第1 秒，3 人接水。第1 秒结束时，1、2、3 号同学每人的已接水量为1，3 号同学接完水，4 号同学接替3 号同学开始接水。第2 秒，3 人接水。第2 秒结束时，1、2 号同学每人的已接水量为2，4 号同学的已接水量为1。第3 秒，3 人接水。第3 秒结束时，1、2 号同学每人的已接水量为3，4 号同学的已接水量为2。4 号同学接完水，5 号同学接替4 号同学开始接水。第4 秒，3 人接水。第4 秒结束时，1、2 号同学每人的已接水量为4，5 号同学的已接水量为1。1、2、5 号同学接完水，即所有人完成接水。总接水时间为4 秒。

**输入样例2**

```c++
8 4 
23 71 87 32 70 93 80 76
```
**输出样例2**
```c++
163
```
**数据范围**

$1≤n≤10000$，$1≤m≤100$且$m≤n$；

$1≤w_i≤100$。

**解题思路**

~~~c++
#include <iostream>
using namespace std;
const int N = 100;
int n, m;
int q[N];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> q[i];
    for (int i = m + 1; i <= n; i++) {
        int x;
        cin >> x;
        int mi = 1e9, idx = 0;
        for (int j = 1; j <= m; j++)
            if (q[j] < mi) mi = q[j], idx = j;
        q[idx] += x;
    }
    int ans = 0;
    for (int i = 1; i <= m; i++)
        if (ans < q[i]) ans = q[i];
    cout << ans;
    return 0;
}
~~~



### 5. 寻宝（2014）

**题目描述**

传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：

藏宝楼共有 N+1 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 N 层，每层 M 个房间，这 M 个房间围成一圈并按逆时针方向依次编号为 0，…，M-1。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 x，表示从这个房间开始按逆时针方向选择第 x 个有楼梯的房间（假定该房间的编号为 k），从该房间上楼，上楼后到达上一层的 k 号房间。比如当前房间的指示牌上写着 2，则按逆时针方向开始尝试，找到第 2 个有楼梯的房间，从该房间上楼。

如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。

请帮助小明算出这个打开宝箱的密钥。

**输入数据**

第一行 2 个整数 N 和 M，之间用一个空格隔开。N 表示除了顶层外藏宝楼共 N 层楼，M 表示除顶层外每层楼有 M 个房间。

接下来 $N*M$ 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第$(i-1)*M+j$行表示第 i 层 j-1 号房间的情况（i=1, 2, …, N；j=1, 2, … ,M）。第一个整数表示该房间是否有楼梯通往上一层（0 表示没有，1 表示有），第二个整数表示指示牌上的数字。注意，从 j 号房间的楼梯爬到上一层到达的房间一定也是 j 号房间。

最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从 0 开始）。

**输出数据**

输出只有一行，一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对 20123取模的结果即可。

**输入样例**

~~~c++
2 3 
1 2 
0 3 
1 4 
0 1 
1 5 
1 2 
1
~~~

**输出样例**

~~~c++
5
~~~

**输入输出样例说明**

第一层：

- 0 号房间，有楼梯通往上层，指示牌上的数字是 2；
- 1 号房间，无楼梯通往上层，指示牌上的数字是 3；
- 2 号房间，有楼梯通往上层，指示牌上的数字是 4；

第二层：

- 0 号房间，无楼梯通往上层，指示牌上的数字是 1；
- 1 号房间，有楼梯通往上层，指示牌上的数字是 5；
- 2 号房间，有楼梯通往上层，指示牌上的数字是 2；

小明首先进入第一层（底层）的 1 号房间，记下指示牌上的数字为 3，然后从这个房间开始，沿逆时针方向选择第 3 个有楼梯的房间 2 号房间进入，上楼后到达第二层的 2 号房间，记下指示牌上的数字为 2，由于当前房间本身有楼梯通向上层，该房间作为第一个有楼梯的房间。因此，此时沿逆时针方向选择第 2 个有楼梯的房间即为 1 号房间，进入后上楼梯到达顶层。这时把上述记下的指示牌上的数字加起来，即 3+2=5，所以打开宝箱的密钥就是 5。

**数据范围**

对于 50%数据，有 $0<N≤1000，0<x≤10000$；

对于 100%数据，有 $0<N≤10000，0<M≤100，0<x≤1,000,000$。

**解题思路**

时间复杂度：$O(n*m)$

空间复杂度：$ O(n*m)$

~~~c++
#include <iostream>
using namespace std;
const int N = 10005, M = 105;
int n, m, k;
int f[N][M], x[N][M], c[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < m; j++) {
            scanf("%d%d", &f[i][j], &x[i][j]);
            if (f[i][j] == 1) c[i]++;
        }
    scanf("%d", &k);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        ans = (ans + x[i][k]) % 20123;
        int p = x[i][k] % c[i];
        if (p == 0) p = c[i];
        while (1) {
            if (f[i][k] == 1) p--;
            if (p == 0) break;
            k = (k + 1) % m;
        }
    }
    cout << ans;
    return 0;
}
~~~



### 6. 买铅笔(2016)

**题目描述**

P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有3种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起见，P老师决定只买同一种包装的铅笔。

商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过n支铅笔才够给小朋友们发礼物。

现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少n支铅笔最少需要花费多少钱。

**输入数据**

输入的第一行包含一个正整数n，表示需要的铅笔数量。

接下来三行，每行用两个正整数描述一种包装的铅笔:其中第一个整数表示这种包装内铅笔的数量，第二个整数表示这种包装的价格。

保证所有的7个数都是不超过10000的正整数。

**输出数据**

输出一行一个整数，表示P老师最少需要花费的钱。

**输入样例**

```c++
57 
2 2 
50 30 
30 27
```
**输出样例**

```c++
54
```

**提示**
铅笔的三种包装分别是:
- 2支装，价格为2;
- 50支装，价格为30;
- 30支装，价格为27。
P老师需要购买至少57支铅笔。如果她选择购买第一种包装，那么她需要购买29份，共计2x29=58支，需要花费的钱为$2*29=58$实际上，P老师会选择购买第三种包装，这样需要买2份。虽然最后买到的铅笔数量更多了，为$30*2=60$支，但花费却减少为$27*2=54$，比第一种少。对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买2份，实际的花费达到了$30*2=60$，因此P老师也不会选择。所以最后输出的答案是54

**样例输入2**

```c++
9998 
128 233 
128 2333 
128 666
```

**样例输出2**
```c++
18407
```

**样例输入3**

```c++
9999 
101 1111 
1 9999 
1111 9999
```

**样例输出3**
```c++
89991
```

**数据规模**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

| 测试点      | 整倍数 | 其他特点                       |
| ----------- | ------ | ------------------------------ |
| 1,2,3,4     | √      | 三种包装内的铅笔数量都是相同的 |
| 5,6,7,8     | ×      | 三种包装内的铅笔数量都是相同的 |
| 9,10,11,12  | √      | 后两种包装的铅笔数量都是相同的 |
| 13,14,15,16 | ×      | 后两种包装的铅笔数量都是相同的 |
| 17,18       | √      | 没有特殊性质                   |

上表中“整倍数”的意义为:若为“k”，表示对应数据所需要的铅笔数量n一定是每种包装铅笔数量的整倍数(这意味着一定可以不用多买铅笔)。

**解题思路**

~~~c++
#include <cmath>
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int ans = 1e9;
    for (int i = 1; i <= 3; i++) {
        int x, y;
        cin >> x >> y;
        int cnt = ceil(n * 1.0 / x);
        ans = min(ans, cnt * y);
    }
    cout << ans;
    return 0;
}
~~~



### 7. 标题统计（2018）

**题目描述**

凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？

注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字符数时，空格和换行符不计算在内。

**输入数据**

输入只有一行，一个字符串 s。

**输出数据**

输出只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。

**输入样例**

```c++
234
```
**输出样例**
```c++
3
```
**样例1说明**

标题中共有 3 个字符，这 3 个字符都是数字字符。

**样例输入2**

```c++
Ca 45
```

**样例输出2**

```c++
4
```
**样例2说明**

标题中共有 5 个字符，包括 1 个大写英文字母，1 个小写英文字母和 2 个数字字符，还有 1 个空格。由于空格不计入结果中，故标题的有效字符数为 4 个。

**数据规模与约定**

规定$ |s|$表示字符串 s 的长度（即字符串中的字符和空格数）。

对于 40%的数据，$1≤|s|≤5$，保证输入为数字字符及行末换行符。

对于 80% 的数据，$1≤|s|≤5$，输入只可能包含大、小写英文字母、数字字符及行末换行符。

对于 100% 的数据，$1≤|s|≤5$，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。

**解题思路**

~~~c++
#include <cstring>
#include <iostream>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    int ans = 0;
    for (int i = 0; s[i]; i++)
        if (s[i] != ' ') ans++;
    cout << ans;
    return 0;
}
~~~



## II 枚举算法

