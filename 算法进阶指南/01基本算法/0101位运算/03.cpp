#include <cstring>
#include <iostream>
using namespace std;
const int N = 20, M = 1 << 20;
int n, g[N][N], f[M][N];
/*
    动态规划 f[i][j]=min(f[i^(1<<j)][k]+g[k][j]);
    i表示已经走过的点的二进制表示（状态压缩）
    例如 0...0001 表示走0号点 0...0011 表示走了0号和1号点
    f[i][j] 可以有其他 k个节点转移过来 但是转移过来的状态应该是没有走过j点
    怎么表示 i^(1<<j)将第j节点设置为 0 ，表示没有访问过 j 节点
*/
int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) cin >> g[i][j];
    //其他节点初始化为无穷大，表示最短距离是不可到达
    memset(f, 0x3f, sizeof(f));
    //初值 从 0 节点开始 所以0节点被访问 i=1 j=0 最短距离 0 
    //为何最短距离是 0 因为自己到自己节点没有代价
    f[1][0] = 0;  
    for (int i = 0; i < (1 << n); i++)
        for (int j = 0; j < n; j++)
            //判断j节点是否已经访问，因为 f[i][j]表示访问到j节点的最短路径
            if (i >> j & 1)
                //枚举节点k k表示 j节点可以通过k来过渡 也就是经过k到j
                for (int k = 0; k < n; k++)
                    //如果要通过k节点过渡 就需要 f[i'][k]中 i'没有访问过j，
                    //才能通过k访问j节点，其次i'必须是访问过k节点的！！
                    //实际包含了两个条件 i ^ (1 << j) 将 j点位置设置为 0
                    // 因为前面有判断 i >> j & 1 说明 j点一定被访问过了 也就是一定是 1
                    // 这里通过 ^ 操作设置为 0 ，变成没有访问
                    // >>k & 1 确保 k 节点是访问过的
                    if ((i ^ (1 << j)) >> k & 1)
                        f[i][j] = min(f[i][j], f[i ^ (1 << j)][k] + g[k][j]);
    cout << f[(1 << n) - 1][n - 1];
    return 0;
}